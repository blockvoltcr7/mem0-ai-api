{"uid":"437eaaeb33463c26","name":"test_add_and_search_memory","fullName":"tests.integration.test_mem0_smoke.TestMem0Smoke#test_add_and_search_memory","historyId":"a042e844400b0a24069d7c6e184bf753","time":{"start":1748211725205,"stop":1748211725206,"duration":1},"description":"Test adding a memory entry and searching for it.","descriptionHtml":"<p>Test adding a memory entry and searching for it.</p>\n","status":"failed","statusMessage":"Failed: Failed to add memory: One of 'user_id', 'agent_id', or 'run_id' must be provided.","statusTrace":"self = <test_mem0_smoke.TestMem0Smoke object at 0x104d43860>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Basic Memory Operations\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    def test_add_and_search_memory(self, memory_instance: Memory):\n        \"\"\"Test adding a memory entry and searching for it.\"\"\"\n        test_memory_text = \"My first memory entry for testing\"\n        test_metadata = {\"test\": \"yes\", \"category\": \"smoke_test\"}\n    \n        with allure.step(\"Add a sample memory\"):\n            try:\n>               result = memory_instance.add(test_memory_text, metadata=test_metadata)\n\ntests/integration/test_mem0_smoke.py:134: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:220: in add\n    processed_metadata, effective_filters = _build_filters_and_metadata(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _build_filters_and_metadata(\n        *, # Enforce keyword-only arguments\n        user_id: Optional[str] = None,\n        agent_id: Optional[str] = None,\n        run_id: Optional[str] = None,\n        actor_id: Optional[str] = None, # For query-time filtering\n        input_metadata: Optional[Dict[str, Any]] = None,\n        input_filters: Optional[Dict[str, Any]] = None,\n    ) -> tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Constructs metadata for storage and filters for querying based on session and actor identifiers.\n    \n        This helper ties every memory/query to exactly one session id (`user_id`, `agent_id`, or `run_id`) and optionally narrows queries to a specific `actor_id`.  It returns two dicts:\n    \n    \n        1. `base_metadata_template`: Used as a template for metadata when storing new memories.\n           It includes the primary session identifier(s) and any `input_metadata`.\n        2. `effective_query_filters`: Used for querying existing memories. It includes the\n           primary session identifier(s), any `input_filters`, and a resolved actor\n           identifier for targeted filtering if specified by any actor-related inputs.\n    \n        Actor filtering precedence: explicit `actor_id` arg → `filters[\"actor_id\"]`\n        This resolved actor ID is used for querying but is not added to `base_metadata_template`,\n        as the actor for storage is typically derived from message content at a later stage.\n    \n        Args:\n            user_id (Optional[str]): User identifier, primarily for Classic Mode session scoping.\n            agent_id (Optional[str]): Agent identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            run_id (Optional[str]): Run identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            actor_id (Optional[str]): Explicit actor identifier, used as a potential source for\n                actor-specific filtering. See actor resolution precedence in the main description.\n            input_metadata (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session identifiers for the storage metadata template. Defaults to an empty dict.\n            input_filters (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session and actor identifiers for query filters. Defaults to an empty dict.\n    \n        Returns:\n            tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing:\n                - base_metadata_template (Dict[str, Any]): Metadata template for storing memories,\n                  scoped to the determined session.\n                - effective_query_filters (Dict[str, Any]): Filters for querying memories,\n                  scoped to the determined session and potentially a resolved actor.\n        \"\"\"\n    \n        base_metadata_template = deepcopy(input_metadata) if input_metadata else {}\n        effective_query_filters = deepcopy(input_filters) if input_filters else {}\n    \n        # ---------- resolve session id (mandatory) ----------\n        session_key, session_val = None, None\n        if user_id:\n            session_key, session_val = \"user_id\", user_id\n        elif agent_id:\n            session_key, session_val = \"agent_id\", agent_id\n        elif run_id:\n            session_key, session_val = \"run_id\", run_id\n    \n        if session_key is None:\n>           raise ValueError(\"One of 'user_id', 'agent_id', or 'run_id' must be provided.\")\nE           ValueError: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:95: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_mem0_smoke.TestMem0Smoke object at 0x104d43860>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Basic Memory Operations\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    def test_add_and_search_memory(self, memory_instance: Memory):\n        \"\"\"Test adding a memory entry and searching for it.\"\"\"\n        test_memory_text = \"My first memory entry for testing\"\n        test_metadata = {\"test\": \"yes\", \"category\": \"smoke_test\"}\n    \n        with allure.step(\"Add a sample memory\"):\n            try:\n                result = memory_instance.add(test_memory_text, metadata=test_metadata)\n    \n                allure.attach(\n                    str(result),\n                    name=\"Add Memory Result\",\n                    attachment_type=allure.attachment_type.TEXT\n                )\n    \n                # Verify the add operation was successful\n                assert result is not None, \"Memory add operation returned None\"\n                print(\"✅ Added a memory successfully\")\n    \n            except Exception as e:\n                allure.attach(\n                    f\"❌ Failed to add memory: {str(e)}\",\n                    name=\"Add Memory Error\",\n                    attachment_type=allure.attachment_type.TEXT\n                )\n>               pytest.fail(f\"Failed to add memory: {str(e)}\")\nE               Failed: Failed to add memory: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\ntests/integration/test_mem0_smoke.py:152: Failed","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"setup_environment","time":{"start":1748211724766,"stop":1748211724767,"duration":1},"status":"passed","steps":[{"name":"Load environment variables","time":{"start":1748211724766,"stop":1748211724766,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"Validate required environment variables","time":{"start":1748211724766,"stop":1748211724767,"duration":1},"status":"passed","steps":[],"attachments":[{"uid":"cd3bd9c464dd0b4","name":"Qdrant Configuration","source":"cd3bd9c464dd0b4.txt","type":"text/plain","size":40}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":2,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"qdrant_health_check","time":{"start":1748211724767,"stop":1748211724783,"duration":16},"status":"passed","steps":[{"name":"Check Qdrant health","time":{"start":1748211724767,"stop":1748211724783,"duration":16},"status":"passed","steps":[],"attachments":[{"uid":"93612fc03102c04a","name":"Qdrant Collections Response","source":"93612fc03102c04a.json","type":"application/json","size":62}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":1,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"memory_instance","time":{"start":1748211724783,"stop":1748211725205,"duration":422},"status":"passed","steps":[{"name":"Initialize Memory layer with Qdrant","time":{"start":1748211724783,"stop":1748211725205,"duration":422},"status":"passed","steps":[],"attachments":[{"uid":"cf203a462af0f3bf","name":"Memory Configuration","source":"cf203a462af0f3bf.json","type":"application/json","size":131},{"uid":"8340585ddcec4a89","name":"Memory Initialization","source":"8340585ddcec4a89.txt","type":"text/plain","size":53}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":2,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":1,"attachmentsCount":2,"hasContent":true,"attachmentStep":false}],"testStage":{"description":"Test adding a memory entry and searching for it.","status":"failed","statusMessage":"Failed: Failed to add memory: One of 'user_id', 'agent_id', or 'run_id' must be provided.","statusTrace":"self = <test_mem0_smoke.TestMem0Smoke object at 0x104d43860>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Basic Memory Operations\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    def test_add_and_search_memory(self, memory_instance: Memory):\n        \"\"\"Test adding a memory entry and searching for it.\"\"\"\n        test_memory_text = \"My first memory entry for testing\"\n        test_metadata = {\"test\": \"yes\", \"category\": \"smoke_test\"}\n    \n        with allure.step(\"Add a sample memory\"):\n            try:\n>               result = memory_instance.add(test_memory_text, metadata=test_metadata)\n\ntests/integration/test_mem0_smoke.py:134: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:220: in add\n    processed_metadata, effective_filters = _build_filters_and_metadata(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _build_filters_and_metadata(\n        *, # Enforce keyword-only arguments\n        user_id: Optional[str] = None,\n        agent_id: Optional[str] = None,\n        run_id: Optional[str] = None,\n        actor_id: Optional[str] = None, # For query-time filtering\n        input_metadata: Optional[Dict[str, Any]] = None,\n        input_filters: Optional[Dict[str, Any]] = None,\n    ) -> tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Constructs metadata for storage and filters for querying based on session and actor identifiers.\n    \n        This helper ties every memory/query to exactly one session id (`user_id`, `agent_id`, or `run_id`) and optionally narrows queries to a specific `actor_id`.  It returns two dicts:\n    \n    \n        1. `base_metadata_template`: Used as a template for metadata when storing new memories.\n           It includes the primary session identifier(s) and any `input_metadata`.\n        2. `effective_query_filters`: Used for querying existing memories. It includes the\n           primary session identifier(s), any `input_filters`, and a resolved actor\n           identifier for targeted filtering if specified by any actor-related inputs.\n    \n        Actor filtering precedence: explicit `actor_id` arg → `filters[\"actor_id\"]`\n        This resolved actor ID is used for querying but is not added to `base_metadata_template`,\n        as the actor for storage is typically derived from message content at a later stage.\n    \n        Args:\n            user_id (Optional[str]): User identifier, primarily for Classic Mode session scoping.\n            agent_id (Optional[str]): Agent identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            run_id (Optional[str]): Run identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            actor_id (Optional[str]): Explicit actor identifier, used as a potential source for\n                actor-specific filtering. See actor resolution precedence in the main description.\n            input_metadata (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session identifiers for the storage metadata template. Defaults to an empty dict.\n            input_filters (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session and actor identifiers for query filters. Defaults to an empty dict.\n    \n        Returns:\n            tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing:\n                - base_metadata_template (Dict[str, Any]): Metadata template for storing memories,\n                  scoped to the determined session.\n                - effective_query_filters (Dict[str, Any]): Filters for querying memories,\n                  scoped to the determined session and potentially a resolved actor.\n        \"\"\"\n    \n        base_metadata_template = deepcopy(input_metadata) if input_metadata else {}\n        effective_query_filters = deepcopy(input_filters) if input_filters else {}\n    \n        # ---------- resolve session id (mandatory) ----------\n        session_key, session_val = None, None\n        if user_id:\n            session_key, session_val = \"user_id\", user_id\n        elif agent_id:\n            session_key, session_val = \"agent_id\", agent_id\n        elif run_id:\n            session_key, session_val = \"run_id\", run_id\n    \n        if session_key is None:\n>           raise ValueError(\"One of 'user_id', 'agent_id', or 'run_id' must be provided.\")\nE           ValueError: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:95: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_mem0_smoke.TestMem0Smoke object at 0x104d43860>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Basic Memory Operations\")\n    @allure.severity(allure.severity_level.CRITICAL)\n    def test_add_and_search_memory(self, memory_instance: Memory):\n        \"\"\"Test adding a memory entry and searching for it.\"\"\"\n        test_memory_text = \"My first memory entry for testing\"\n        test_metadata = {\"test\": \"yes\", \"category\": \"smoke_test\"}\n    \n        with allure.step(\"Add a sample memory\"):\n            try:\n                result = memory_instance.add(test_memory_text, metadata=test_metadata)\n    \n                allure.attach(\n                    str(result),\n                    name=\"Add Memory Result\",\n                    attachment_type=allure.attachment_type.TEXT\n                )\n    \n                # Verify the add operation was successful\n                assert result is not None, \"Memory add operation returned None\"\n                print(\"✅ Added a memory successfully\")\n    \n            except Exception as e:\n                allure.attach(\n                    f\"❌ Failed to add memory: {str(e)}\",\n                    name=\"Add Memory Error\",\n                    attachment_type=allure.attachment_type.TEXT\n                )\n>               pytest.fail(f\"Failed to add memory: {str(e)}\")\nE               Failed: Failed to add memory: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\ntests/integration/test_mem0_smoke.py:152: Failed","steps":[{"name":"Add a sample memory","time":{"start":1748211725205,"stop":1748211725206,"duration":1},"status":"failed","statusMessage":"Failed: Failed to add memory: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n","statusTrace":"  File \"/Users/samisabir-idrissi/code/ssiautomationsapps/mem01-ai-tutor/tests/integration/test_mem0_smoke.py\", line 152, in test_add_and_search_memory\n    pytest.fail(f\"Failed to add memory: {str(e)}\")\n  File \"/Users/samisabir-idrissi/code/ssiautomationsapps/mem01-ai-tutor/.venv/lib/python3.12/site-packages/_pytest/outcomes.py\", line 178, in fail\n    raise Failed(msg=reason, pytrace=pytrace)\n","steps":[],"attachments":[{"uid":"89b2c33a36f4aadc","name":"Add Memory Error","source":"89b2c33a36f4aadc.txt","type":"text/plain","size":85}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false}],"attachments":[{"uid":"1561bba123066e57","name":"Exception","source":"1561bba123066e57.txt","type":"text/plain","size":81},{"uid":"4b8f01b963bec4cd","name":"log","source":"4b8f01b963bec4cd.txt","type":"text/plain","size":1056}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":1,"attachmentsCount":3,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"epic","value":"Memory Management"},{"name":"severity","value":"critical"},{"name":"story","value":"Basic Memory Operations"},{"name":"feature","value":"Mem0 Vector Database Integration"},{"name":"parentSuite","value":"tests.integration"},{"name":"suite","value":"test_mem0_smoke"},{"name":"subSuite","value":"TestMem0Smoke"},{"name":"host","value":"samis-MacBook-Pro.local"},{"name":"thread","value":"8876-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.integration.test_mem0_smoke"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"437eaaeb33463c26.json","parameterValues":[]}