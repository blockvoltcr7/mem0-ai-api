{"uid":"6ae48b8690840814","name":"test_multiple_memories_and_search","fullName":"tests.integration.test_mem0_smoke.TestMem0Smoke#test_multiple_memories_and_search","historyId":"02613aaa38f5cb703862d0414892cc1e","time":{"start":1748211725275,"stop":1748211725275,"duration":0},"description":"Test adding multiple memories and searching with different queries.","descriptionHtml":"<p>Test adding multiple memories and searching with different queries.</p>\n","status":"failed","statusMessage":"Failed: Failed to add memory 1: One of 'user_id', 'agent_id', or 'run_id' must be provided.","statusTrace":"self = <test_mem0_smoke.TestMem0Smoke object at 0x104d4ba40>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Memory Persistence\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_multiple_memories_and_search(self, memory_instance: Memory):\n        \"\"\"Test adding multiple memories and searching with different queries.\"\"\"\n        memories = [\n            {\"text\": \"I love programming in Python\", \"metadata\": {\"topic\": \"programming\"}},\n            {\"text\": \"Machine learning is fascinating\", \"metadata\": {\"topic\": \"ai\"}},\n            {\"text\": \"Vector databases are powerful for similarity search\", \"metadata\": {\"topic\": \"database\"}},\n        ]\n    \n        with allure.step(\"Add multiple memories\"):\n            for i, memory_data in enumerate(memories):\n                try:\n>                   result = memory_instance.add(memory_data[\"text\"], metadata=memory_data[\"metadata\"])\n\ntests/integration/test_mem0_smoke.py:204: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:220: in add\n    processed_metadata, effective_filters = _build_filters_and_metadata(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _build_filters_and_metadata(\n        *, # Enforce keyword-only arguments\n        user_id: Optional[str] = None,\n        agent_id: Optional[str] = None,\n        run_id: Optional[str] = None,\n        actor_id: Optional[str] = None, # For query-time filtering\n        input_metadata: Optional[Dict[str, Any]] = None,\n        input_filters: Optional[Dict[str, Any]] = None,\n    ) -> tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Constructs metadata for storage and filters for querying based on session and actor identifiers.\n    \n        This helper ties every memory/query to exactly one session id (`user_id`, `agent_id`, or `run_id`) and optionally narrows queries to a specific `actor_id`.  It returns two dicts:\n    \n    \n        1. `base_metadata_template`: Used as a template for metadata when storing new memories.\n           It includes the primary session identifier(s) and any `input_metadata`.\n        2. `effective_query_filters`: Used for querying existing memories. It includes the\n           primary session identifier(s), any `input_filters`, and a resolved actor\n           identifier for targeted filtering if specified by any actor-related inputs.\n    \n        Actor filtering precedence: explicit `actor_id` arg â†’ `filters[\"actor_id\"]`\n        This resolved actor ID is used for querying but is not added to `base_metadata_template`,\n        as the actor for storage is typically derived from message content at a later stage.\n    \n        Args:\n            user_id (Optional[str]): User identifier, primarily for Classic Mode session scoping.\n            agent_id (Optional[str]): Agent identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            run_id (Optional[str]): Run identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            actor_id (Optional[str]): Explicit actor identifier, used as a potential source for\n                actor-specific filtering. See actor resolution precedence in the main description.\n            input_metadata (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session identifiers for the storage metadata template. Defaults to an empty dict.\n            input_filters (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session and actor identifiers for query filters. Defaults to an empty dict.\n    \n        Returns:\n            tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing:\n                - base_metadata_template (Dict[str, Any]): Metadata template for storing memories,\n                  scoped to the determined session.\n                - effective_query_filters (Dict[str, Any]): Filters for querying memories,\n                  scoped to the determined session and potentially a resolved actor.\n        \"\"\"\n    \n        base_metadata_template = deepcopy(input_metadata) if input_metadata else {}\n        effective_query_filters = deepcopy(input_filters) if input_filters else {}\n    \n        # ---------- resolve session id (mandatory) ----------\n        session_key, session_val = None, None\n        if user_id:\n            session_key, session_val = \"user_id\", user_id\n        elif agent_id:\n            session_key, session_val = \"agent_id\", agent_id\n        elif run_id:\n            session_key, session_val = \"run_id\", run_id\n    \n        if session_key is None:\n>           raise ValueError(\"One of 'user_id', 'agent_id', or 'run_id' must be provided.\")\nE           ValueError: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:95: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_mem0_smoke.TestMem0Smoke object at 0x104d4ba40>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Memory Persistence\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_multiple_memories_and_search(self, memory_instance: Memory):\n        \"\"\"Test adding multiple memories and searching with different queries.\"\"\"\n        memories = [\n            {\"text\": \"I love programming in Python\", \"metadata\": {\"topic\": \"programming\"}},\n            {\"text\": \"Machine learning is fascinating\", \"metadata\": {\"topic\": \"ai\"}},\n            {\"text\": \"Vector databases are powerful for similarity search\", \"metadata\": {\"topic\": \"database\"}},\n        ]\n    \n        with allure.step(\"Add multiple memories\"):\n            for i, memory_data in enumerate(memories):\n                try:\n                    result = memory_instance.add(memory_data[\"text\"], metadata=memory_data[\"metadata\"])\n                    assert result is not None, f\"Failed to add memory {i+1}\"\n    \n                    allure.attach(\n                        f\"Memory {i+1}: {memory_data['text']}\",\n                        name=f\"Added Memory {i+1}\",\n                        attachment_type=allure.attachment_type.TEXT\n                    )\n                except Exception as e:\n>                   pytest.fail(f\"Failed to add memory {i+1}: {str(e)}\")\nE                   Failed: Failed to add memory 1: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\ntests/integration/test_mem0_smoke.py:213: Failed","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"setup_environment","time":{"start":1748211724766,"stop":1748211724767,"duration":1},"status":"passed","steps":[{"name":"Load environment variables","time":{"start":1748211724766,"stop":1748211724766,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"Validate required environment variables","time":{"start":1748211724766,"stop":1748211724767,"duration":1},"status":"passed","steps":[],"attachments":[{"uid":"cd3bd9c464dd0b4","name":"Qdrant Configuration","source":"cd3bd9c464dd0b4.txt","type":"text/plain","size":40}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":2,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"qdrant_health_check","time":{"start":1748211724767,"stop":1748211724783,"duration":16},"status":"passed","steps":[{"name":"Check Qdrant health","time":{"start":1748211724767,"stop":1748211724783,"duration":16},"status":"passed","steps":[],"attachments":[{"uid":"93612fc03102c04a","name":"Qdrant Collections Response","source":"93612fc03102c04a.json","type":"application/json","size":62}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":1,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},{"name":"memory_instance","time":{"start":1748211724783,"stop":1748211725205,"duration":422},"status":"passed","steps":[{"name":"Initialize Memory layer with Qdrant","time":{"start":1748211724783,"stop":1748211725205,"duration":422},"status":"passed","steps":[],"attachments":[{"uid":"cf203a462af0f3bf","name":"Memory Configuration","source":"cf203a462af0f3bf.json","type":"application/json","size":131},{"uid":"8340585ddcec4a89","name":"Memory Initialization","source":"8340585ddcec4a89.txt","type":"text/plain","size":53}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":2,"hasContent":true,"attachmentStep":false}],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":1,"attachmentsCount":2,"hasContent":true,"attachmentStep":false}],"testStage":{"description":"Test adding multiple memories and searching with different queries.","status":"failed","statusMessage":"Failed: Failed to add memory 1: One of 'user_id', 'agent_id', or 'run_id' must be provided.","statusTrace":"self = <test_mem0_smoke.TestMem0Smoke object at 0x104d4ba40>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Memory Persistence\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_multiple_memories_and_search(self, memory_instance: Memory):\n        \"\"\"Test adding multiple memories and searching with different queries.\"\"\"\n        memories = [\n            {\"text\": \"I love programming in Python\", \"metadata\": {\"topic\": \"programming\"}},\n            {\"text\": \"Machine learning is fascinating\", \"metadata\": {\"topic\": \"ai\"}},\n            {\"text\": \"Vector databases are powerful for similarity search\", \"metadata\": {\"topic\": \"database\"}},\n        ]\n    \n        with allure.step(\"Add multiple memories\"):\n            for i, memory_data in enumerate(memories):\n                try:\n>                   result = memory_instance.add(memory_data[\"text\"], metadata=memory_data[\"metadata\"])\n\ntests/integration/test_mem0_smoke.py:204: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:220: in add\n    processed_metadata, effective_filters = _build_filters_and_metadata(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def _build_filters_and_metadata(\n        *, # Enforce keyword-only arguments\n        user_id: Optional[str] = None,\n        agent_id: Optional[str] = None,\n        run_id: Optional[str] = None,\n        actor_id: Optional[str] = None, # For query-time filtering\n        input_metadata: Optional[Dict[str, Any]] = None,\n        input_filters: Optional[Dict[str, Any]] = None,\n    ) -> tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Constructs metadata for storage and filters for querying based on session and actor identifiers.\n    \n        This helper ties every memory/query to exactly one session id (`user_id`, `agent_id`, or `run_id`) and optionally narrows queries to a specific `actor_id`.  It returns two dicts:\n    \n    \n        1. `base_metadata_template`: Used as a template for metadata when storing new memories.\n           It includes the primary session identifier(s) and any `input_metadata`.\n        2. `effective_query_filters`: Used for querying existing memories. It includes the\n           primary session identifier(s), any `input_filters`, and a resolved actor\n           identifier for targeted filtering if specified by any actor-related inputs.\n    \n        Actor filtering precedence: explicit `actor_id` arg â†’ `filters[\"actor_id\"]`\n        This resolved actor ID is used for querying but is not added to `base_metadata_template`,\n        as the actor for storage is typically derived from message content at a later stage.\n    \n        Args:\n            user_id (Optional[str]): User identifier, primarily for Classic Mode session scoping.\n            agent_id (Optional[str]): Agent identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            run_id (Optional[str]): Run identifier, for Classic Mode session scoping or\n                as auxiliary information in Group Mode.\n            actor_id (Optional[str]): Explicit actor identifier, used as a potential source for\n                actor-specific filtering. See actor resolution precedence in the main description.\n            input_metadata (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session identifiers for the storage metadata template. Defaults to an empty dict.\n            input_filters (Optional[Dict[str, Any]]): Base dictionary to be augmented with\n                session and actor identifiers for query filters. Defaults to an empty dict.\n    \n        Returns:\n            tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing:\n                - base_metadata_template (Dict[str, Any]): Metadata template for storing memories,\n                  scoped to the determined session.\n                - effective_query_filters (Dict[str, Any]): Filters for querying memories,\n                  scoped to the determined session and potentially a resolved actor.\n        \"\"\"\n    \n        base_metadata_template = deepcopy(input_metadata) if input_metadata else {}\n        effective_query_filters = deepcopy(input_filters) if input_filters else {}\n    \n        # ---------- resolve session id (mandatory) ----------\n        session_key, session_val = None, None\n        if user_id:\n            session_key, session_val = \"user_id\", user_id\n        elif agent_id:\n            session_key, session_val = \"agent_id\", agent_id\n        elif run_id:\n            session_key, session_val = \"run_id\", run_id\n    \n        if session_key is None:\n>           raise ValueError(\"One of 'user_id', 'agent_id', or 'run_id' must be provided.\")\nE           ValueError: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\n.venv/lib/python3.12/site-packages/mem0/memory/main.py:95: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_mem0_smoke.TestMem0Smoke object at 0x104d4ba40>\nmemory_instance = <mem0.memory.main.Memory object at 0x104d43620>\n\n    @allure.story(\"Memory Persistence\")\n    @allure.severity(allure.severity_level.NORMAL)\n    def test_multiple_memories_and_search(self, memory_instance: Memory):\n        \"\"\"Test adding multiple memories and searching with different queries.\"\"\"\n        memories = [\n            {\"text\": \"I love programming in Python\", \"metadata\": {\"topic\": \"programming\"}},\n            {\"text\": \"Machine learning is fascinating\", \"metadata\": {\"topic\": \"ai\"}},\n            {\"text\": \"Vector databases are powerful for similarity search\", \"metadata\": {\"topic\": \"database\"}},\n        ]\n    \n        with allure.step(\"Add multiple memories\"):\n            for i, memory_data in enumerate(memories):\n                try:\n                    result = memory_instance.add(memory_data[\"text\"], metadata=memory_data[\"metadata\"])\n                    assert result is not None, f\"Failed to add memory {i+1}\"\n    \n                    allure.attach(\n                        f\"Memory {i+1}: {memory_data['text']}\",\n                        name=f\"Added Memory {i+1}\",\n                        attachment_type=allure.attachment_type.TEXT\n                    )\n                except Exception as e:\n>                   pytest.fail(f\"Failed to add memory {i+1}: {str(e)}\")\nE                   Failed: Failed to add memory 1: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n\ntests/integration/test_mem0_smoke.py:213: Failed","steps":[{"name":"Add multiple memories","time":{"start":1748211725275,"stop":1748211725275,"duration":0},"status":"failed","statusMessage":"Failed: Failed to add memory 1: One of 'user_id', 'agent_id', or 'run_id' must be provided.\n","statusTrace":"  File \"/Users/samisabir-idrissi/code/ssiautomationsapps/mem01-ai-tutor/tests/integration/test_mem0_smoke.py\", line 213, in test_multiple_memories_and_search\n    pytest.fail(f\"Failed to add memory {i+1}: {str(e)}\")\n  File \"/Users/samisabir-idrissi/code/ssiautomationsapps/mem01-ai-tutor/.venv/lib/python3.12/site-packages/_pytest/outcomes.py\", line 178, in fail\n    raise Failed(msg=reason, pytrace=pytrace)\n","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":0,"hasContent":true,"attachmentStep":false}],"attachments":[{"uid":"1cd59bc949e79d2a","name":"Exception","source":"1cd59bc949e79d2a.txt","type":"text/plain","size":83}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":1,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[],"labels":[{"name":"epic","value":"Memory Management"},{"name":"severity","value":"normal"},{"name":"story","value":"Memory Persistence"},{"name":"feature","value":"Mem0 Vector Database Integration"},{"name":"parentSuite","value":"tests.integration"},{"name":"suite","value":"test_mem0_smoke"},{"name":"subSuite","value":"TestMem0Smoke"},{"name":"host","value":"samis-MacBook-Pro.local"},{"name":"thread","value":"8876-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.integration.test_mem0_smoke"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"6ae48b8690840814.json","parameterValues":[]}